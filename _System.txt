* Main
- Concept
	Object Oriented Programming
	Synchronous vs Asynchronous / Blocking vs Non-Blocking
- Code
	Algorithms
		Cracking the Coding Interview(6E)
			Data Structure(Array, List, Linked List, Stack & Queue, Tree, Graph)
			Bit Manipulation
			Math & Logic Puzzle
			Object Oriented Programming
			Recursion & Dynamic Programming
			Scalability
			Sort & Search
			Thread & Lock
	Design Patterns

* Portfolio
- Responsive Web Full Stack
	Springless
	SpringMVC
	SpringBoot

* Reference
- Linux
- Start Bootstrap

* Progress
- Book Scan
	Clean Code 클린 코드(로버트 C. 마틴 / 인사이트)



--------------------------------------------------< ? >--------------------------------------------------

// ...



--------------------------------------------------< Object Oriented Programming >--------------------------------------------------

* 4 Characteristics
- Abstraction : 클래스들의 공통적인 특성(변수, 메소드)들을 인터페이스로 묶어 표현함
- Encapsulation : 관련된 데이터와 함수를 묶어줌
	Information Hiding : 캡슐 속의 데이터와 함수를 외부에 노출시키지 않음
- Inheritance : 자식 클래스가 부모 클래스의 특성을 물려받음
- Polymorphism : 하나의 클래스가 다양한 방식으로 동작함
	Overloading : 클래스의 메소드 이름이 같지만 파라미터가 다름
	Overriding : 부모 클래스의 메소드를 자식 클래스의 메소드의 용도에 맞게 재정의하여 사용함

* 5 Principles(SOLID)
- SRP(Single Responsibility Principle) : 한 클래스는 하나의 책임만 가져야 한다.
- OCP(Open Closed Principle) : 확장에는 열려있으나 변경에는 닫혀있어야 한다.
- LSP(Liskov's Substitution Principle) : 프로그램의 객체는 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- ISP(Interface Segregation Principle) : 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다.
- DIP(Dependency Inversion Principle) : 추상화에 의존한다. 구체화에 의존하면 안 된다.



--------------------------------------------------< Design Patterns >--------------------------------------------------

* [Creational] Abstract Factory
- Provide an interface for creating families of related or dependent objects
  without specifying their concrete classes.
  // Code...

* [Creational] Builder
- Separate the construction of a complex object from its representation
  so that the same construction process can create different representations.
  // Code...

* [Creational] Factory Method
- Define an interface for creating an object, but let subclasses decide which class to instantiate.
  Factory Method lets a class defer instantiation to subclasses.
  // Code...

* [Creational] Prototype
- Specify the kinds of objects to create using a prototypical instance,
  and create new objects by copying this prototype.
  // Code...

* [Creational] Singleton
- Ensure a class only has one instance, and provide a global point of access to it.
  // Code...

* [Structural] Adapter
- Convert the interface of a class into another interface clients expect.
  Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.
  // Code...

* [Structural] Bridge
- Decouple an abstraction from its implementation so that the two can vary independently.
  // Code...

* [Structural] Composite
- Compose objects into tree structures to represent part-whole hierarchies.
  Composite lets clients treat individual objects and compositions of objects uniformly.
  // Code...

* [Structural] Decorator
- Attach additional responsibilities to an object dynamically.
  Decorators provide a flexible alternative to subclassing for extending functionality.
  // Code...

* [Structural] Facade
- Provide a unified interface to a set of interfaces in a subsystem.
  Facade defines a higher-level interface that makes the subsystem easier to use.
  // Code...

* [Structural] Flyweight
- Use sharing to support large numbers of fine-grained objects efficiently.
  // Code...

* [Structural] Proxy
- Provide a surrogate or placeholder for another object to control access to it.
  // Code...

* [Behavioral] Chain of Responsibility
- Avoid coupling the sender of a request to its receiver
  by giving more than one object a chance to handle the request.
  Chain the receiving objects and pass the request along the chain until an object handles it.
  // Code...

* [Behavioral] Command
- Encapsulate a request as an object,
  thereby letting you parameterize clients with different requests, queue or log requests,
  and support undoable operations.
  // Code...

* [Behavioral] Interpreter
- Given a language, define a representation for its grammar along with an interpreter
  that uses the representation to interpret sentences in the language.
  // Code...

* [Behavioral] Iterator
- Provide a way to access the elements of an aggregate object sequentially
  without exposing its underlying representation.
  // Code...

* [Behavioral] Mediator
- Define an object that encapsulates how a set of objects interact.
  Mediator promotes loose coupling by keeping objects from referring to each other explicitly,
  and it lets you vary their interaction independently.
  // Code...

* [Behavioral] Memento
- Without violating encapsulation, capture and externalize an object's internal state
  so that the object can be restored to this state later.
  // Code...

* [Behavioral] Observer
- Define a one-to-many dependency between objects
  so that when one object changes state, all its dependents are notified and updated automatically.
  // Code...

* [Behavioral] State
- Allow an object to alter its behavior when its internal state changes.
  The object will appear to change its class.
  // Code...

* [Behavioral] Strategy
- Define a family of algorithms, encapsulate each one, and make them interchangeable.
  Strategy lets the algorithm vary independently from clients that use it.
  // Code...

* [Behavioral] Template Method
- Define the skeleton of an algorithm in an operation, deferring some steps to subclasses.
  Template Method lets subclasses redefine certain steps of an algorithm
  without changing the algorithm's structure.
  // Code...

* [Behavioral] Visitor
- Represent an operation to be performed on the elements of an object structure.
  Visitor lets you define a new operation without changing the classes of the elements on which it operates.
  // Code...



--------------------------------------------------< Synchronous vs Asynchronous / Blocking vs Non-Blocking >--------------------------------------------------

* Distinction
- Blocking vs Non-Blocking (제어권, IO) : 호출되는 함수의 결과를... 바로 리턴하지 않음 vs 바로 리턴함
- Synchronous vs Asynchronous (시간) : 호출되는 함수의 작업 완료를 호출된 함수가... 신경씀 vs 신경쓰지 않음

* Feature
- Waiting for system call's completion : Synchronous, Blocking
- Immediate return : Asynchronous, Non-Blocking
- Return with data : Synchronous, Blocking, Non-Blocking
- Waiting in a waiting queue : Blocking

* Comment1
- Non-Blocking : 제어문 수준에서 지체없이 반환하는 것
- Asynchronous : 별도의 쓰레드를 빼서 실행하고 완료되면 호출하는 측에 알려주는 것

* Comment2
- Blocking vs Non-Blocking : 호출한 입장에서의 특징
- Synchronous vs Asynchronous : 처리되는 방식의 특징



--------------------------------------------------< ? >--------------------------------------------------

// ...


